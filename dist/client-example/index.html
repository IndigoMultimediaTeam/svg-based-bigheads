<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <style>
        [contenteditable=""] {
            --color: #44b644;
            display: block;
            font-family: "Lucida Console", Monaco, monospace;
            font-size: .75em;
            line-height: 1.5em;
            font-weight: bold;
            white-space: break-spaces;
            padding: 1rem;
            margin: -.25rem auto .5rem auto;
            border: .25rem dotted var(--color);
        }
        [contenteditable=""]::before { content: "Styles (editable)"; color: var(--color); }
        [data-js_hide_inside=true]{ height: 2rem; }
        [data-js_hide_inside=true] .colorButton{ display: none; }
        svg-bigheads, svg-bigheads-part { display: inline-block; overflow: hidden; }
        .colorButton{
            display: block;
            width: 2rem;
            height: 2rem;
            border: 2px solid transparent;
            border-radius: 100%;
            outline: none;
        }
        .colorButton:focus{ border-color: rgba(0,0,0,.25); }
        [data-js_active="0"] [data-current="0"], [data-js_active="1"] [data-current="1"]{ border-color: black;}
        article{ width: fit-content; margin: 1rem auto; }
        div{ display: flex; flex-flow: row nowrap; justify-content: space-evenly; align-items: center; min-width: fit-content; width: 40rem; margin: auto; }
        div+div{ margin-top: 1rem; }
    </style>
</head>
<body>
    <a href="https://github.com/IndigoMultimediaTeam/svg-based-bigheads/">‚Üê Back to repository</a>
    <article>
        <style contenteditable="">
            svg-bigheads, svg-bigheads-part {
                /* avatar toggles */
                --bigheads-show-lashes: 0;
                /* avatar outer style */
                --size: 15em;
                width: var(--size, 15em);
                height: var(--size, 15em);
                border: 3px solid black;
                border-radius: 100%;
            }
            svg-bigheads-part{ --size: 7.5em; }
        </style>
        <div><!-- buttons --></div>
        <div><!-- colors --></div>
        <div><!-- main --></div>
        <div><!-- gender --></div>
        <script type="module">
 	import { parts_dictionary, colors as colors_initial, isNotGenderType } from "../client/bigheads-module.js";
const [ wrapper_buttons, wrapper_colors, wrapper_avatar, wrapper_below ]= document.getElementsByTagName("article")[0].getElementsByTagName("div");
const href= "../client/bigheads.svg";
let config= randomPartsConfig(parts_dictionary);
const config_keys= Object.keys(config).filter(isNotGenderType).filter(n=> parts_dictionary[n].length>1);
let colors= randomColorsConfig(colors_initial);
let active_type= config_keys[randomTill(config_keys.length)];
const style_colors= document.head.appendChild(createElement("style", { innerHTML: colorStyle() }));

/** @type {HTMLElement[]} */
const parts_els= Array.from({ length: 2 }).map(()=> createElement("svg-bigheads-part", { href }, {
    type: active_type, value: config[active_type], onclick: changeAvatar
}));
updateColorsButtons(active_type);
wrapper_avatar.appendChild(parts_els[0]);
const avatar_el= wrapper_avatar.appendChild(createElement("svg-bigheads", { href }, config));
wrapper_avatar.appendChild(parts_els[1]);
updatePartsValues();

config_keys
    .forEach(value=> wrapper_buttons.appendChild(createElement("button", { value, onclick: updatePartsTypes, textContent: buttonName(value) })));
    wrapper_below.appendChild(createElement("button", {
        textContent: "Change gender",
        onclick: function(){
            const value= config.breasts&&config.breasts==="breasts" ? "none" : "breasts";
            config.breasts= value;
            avatar_el.breasts= value;
        }
    }));
colors.skin.values.map((color, value)=> wrapper_below.appendChild(createElement("button", {
        className: "colorButton", onclick: updateColor, value, style: `background-color: ${color};`, color_type: "skin"
    })))
    .forEach((el, i)=> Reflect.set(el.dataset, "current", i));
wrapper_below.appendChild(createElement("button", { textContent: "Random", onclick: ()=> location.reload() }));

function changeAvatar(){
    const [ type, value ]= this.config;
    config[type]= value;
    avatar_el.setAttribute(type, value);
    updatePartsValues(getShift(parts_els.indexOf(this)));
}
function cssColorName(name){ return "--bigheads-color-"+name; }
/** @this {HTMLElement} */
function updateColor(){
    const { value, color_type= active_type }= this;
    Reflect.set(colors[color_type], "current", value);
    Reflect.set(this.parentElement.dataset, "js_active", value);
    Object.assign(style_colors, { innerHTML: colorStyle() });
}
function updateColorsButtons(type){
    const toggleWrapper= Reflect.set.bind(null, wrapper_colors.dataset, "js_hide_inside");
    if(!Reflect.has(colors, type)) return toggleWrapper(true);
    emptyElement(wrapper_colors);
    const { values, current }= colors[type];
    Reflect.set(wrapper_colors.dataset, "js_active", current);
    values
        .map((color, value)=> wrapper_colors.appendChild(createElement("button", {
            className: "colorButton", onclick: updateColor, value, style: `background-color: ${color};`
        })))
        .forEach((el, i)=> Reflect.set(el.dataset, "current", i));
    toggleWrapper(false);
}
function updatePartsValues(shift= 0){
    parts_els.forEach((el, i)=> el.nextValue(shift||getShift(i)));
}
function updatePartsTypes(){
    const { value }= this;
    parts_els.forEach(el=> {
        Reflect.set(el, "type", value);
        Reflect.set(el, "value", config[value]);
    });
    active_type= value;
    updatePartsValues();
    updateColorsButtons(value);
}
function randomPartsConfig(parts_dictionary){
    return Object.keys(parts_dictionary).reduce(function(out, type){
        const values= parts_dictionary[type];
        Reflect.set(out, type, values[randomTill(values.length)]);
        return out;
    }, {});
}
function randomColorsConfig(colors_initial){
    return Object.keys(colors_initial).reduce(function(out, curr){
        const values= [ colors_initial[curr] ];
        switch(curr){
            case "skin":    values.push("#efbf8f"); break;
            case "hat":     values.push("#8fb7ef"); break;
            case "clothes": values.push("#ef8fb7"); break;
            case "hair":    values.push("#ef8f8f"); break;
            case "mouth":   values.push("#f28297"); break;
        }
        Reflect.set(out, curr, { values, current: randomTill(2) });
        return out;
    }, {});
}

function colorStyle(){ return "svg-bigheads, svg-bigheads-part{"+Object.keys(colors).map(name=> cssColorName(name)+": "+colors[name].values[colors[name].current]+";").join("")+"}"; }
function createElement(name, ...params){ return Object.assign(document.createElement(name), ...params); }
function emptyElement(container){
    let len = container.childNodes.length;
    while(len--){ container.removeChild(container.lastChild); }
}
function getShift(i){ return i?1:-1; }
function buttonName(value){ return value.charAt(0).toUpperCase()+value.slice(1); }
function randomTill(max= 1){
    const { floor, random }= Math;
    return floor(random()*max);
}
        </script>
    </article>
</body>
</html>
